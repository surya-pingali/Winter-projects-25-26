# -*- coding: utf-8 -*-
"""assignment1_soln.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-b7qMt3DQJ4mLXEi6P7KQlhlsQWtrNYG

Part 1: Theoretical **Questions**

Q1. Mutable Default Arguments

If we define the function the way the question shows, the data keeps carrying over from one call to the next. Because a list is a mutable object, once we pass it as a default argument, Python holds on to the same list in memory. So whenever the function is called again without a new list, it keeps using that old list, and the previous values show up again.

To avoid this problem, we give the function an immutable default value instead.for example,
"""

def add_item(item, box=None):

"""Q2. __str__ vs __repr__

__str__() is meant to return a clean, user-friendly stringâ€”something readable for the general user.
__repr__(), on the other hand, is meant to give a more detailed and precise representation of the object, mainly for programmers and debugging.

So the audience for str() is the end-user, while the audience for repr() is developers.

Also, if a class does not define __str__(), Python automatically falls back to using __repr__() instead.

Q3. Class Variables vs. Instance Variables

Since a class variable belongs to the entire class, only one copy of it is stored in memory and every object refers to that same value. Instance variables, however, are created inside __init__, so each object gets its own separate copy in memory.

If you change the class variable using the class name, the update is reflected across all existing objects that rely on that variable. But if you change it through a specific instance, Python simply creates an instance variable with the same name for that object. Only that one object sees the new value, while all other instances continue using the original class variable.

**Part 2: Programming Challenges**

Q4. Complex Dictionary Parsing (Log Analysis)
"""

logstring="User1: Login; User2: Login; User1: Logout; User3: Login; User2:Logout"
#def parselogstring(logstring):
dic=dict()
loglist=logstring.split(";")



for entry in loglist:
  entry = entry.strip()


  user,action = entry.split(":",1)
  user = user.strip()
  action = action.strip()


  if user not in dic:
    dic[user]='Offline'

  if action == 'Login':
    dic[user]='Online'
  elif action == 'Logout':
    dic[user]='Offline'


print(dic)

"""Q5. The "Safe" Calculator (Error Handling)"""

while True:
    try:
        a= float(input("input no.1: " ))
        b= float(input("input no.2: " ))

        op=input("enter operator")

        if op == '+':
            result = a + b
        elif op == '-':
            result = a - b
        elif op == '*':
            result = a * b
        elif op == '/':
            result = a / b




    except ZeroDivisionError:
          print("Cannot divide by zero")

    except ValueError:
        print("please enter numbers only")

    else:
        print(result)

    finally:
        print("Execution attempt complete\n")

"""**Part 3: Advanced OOP Challenges**

Q6. Class Interaction & State Management (The Library System)
"""

class Book:

    def __init__(self, title, author):
        self.title = title
        self.author = author
        self.is_checked_out = False


b=Book("The Alchemist","Paulo Coelho")
print(b.title)
print(b.author)
print(b.is_checked_out)
b.show_info()

class Library:
    def __init__(self):
      self.books = []


    def add_book(self,book_obj):
      self.books.append(book_obj)


    def checkout_book(self, title):
      for book in self.books:
          if self.title == title:
            if book.is_checked_out == False:
                 book.is_checked_out = True
                 return
            else:
              print("already cheched out")
              return
      print("book not found")


    def return_book(self, title):
        for book in self.books:
            if book.title == title:
                book.is_checked_out = False
                print("book returned")
                return
        print("book not found")

"""Q7. Encapsulation with Property Decorators"""

class Employee:
    def __init__(self, first, last, realsalary):
        self.first = first
        self.last = last
        self.realsalary = realsalary

    @property
    def email(self):
      return f"{self.first}.{self.last}@company.com"   #replacement for ==> return first+'.'+last+"@company.com"


    @property
    def salary(self):
        return self.realsalary


    @salary.setter
    def salary(self, value):
        if value < 0:
            raise ValueError("salary cant be negative")
        self.realsalary = value



    @property
    def fullname(self):
        return f"{self.first} {self.last}"

    @fullname.setter
    def fullname(self, name):
        first, last = name.split(" ")
        self.first = first
        self.last = last

    @fullname.deleter
    def fullname(self):
        self.first = None
        self.last = None

"""Q8. Operator Overloading (Magic Methods)"""

class TimeDuration:
  def __init__ (self, hours=0, minutes=0):
    self.hours = hours
    self.minutes = minutes
    self. normalize()


  def normalize(self):
    extra, self.minutes = divmod(self.minutes, 60)
    self.hours += extra


  def __add__ (self, other):
    return TimeDuration(self.hours + other.hours, self.minutes + other.minutes)

  def __str__ (self):
      return f"{self.hours}H:{self.minutes}M"


t1 = TimeDuration(2, 45)
t2 = TimeDuration(1, 30)

t3 = t1 + t2
print(t3)